{"searchDocs":[{"title":"MultiTowerServer","type":0,"sectionRef":"#","url":"/MTK-Dev/api/MultiTowerServer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"MultiTowerServer","url":"/MTK-Dev/api/MultiTowerServer#functions","content":" ","version":null,"tagName":"h2"},{"title":"PlayerLoadTower​","type":1,"pageTitle":"MultiTowerServer","url":"/MTK-Dev/api/MultiTowerServer#PlayerLoadTower","content":"This item only works when running on the server. Server &lt;/&gt; MultiTowerServer.PlayerLoadTower( playerName: string, towerName: string, resetTimer: boolean ) → () Loads a tower by loading the COs, teleporting the player to the tower, and resetting their timer if needed ","version":null,"tagName":"h3"},{"title":"Configuration","type":0,"sectionRef":"#","url":"/MTK-Dev/docs/Configuration","content":"","keywords":"","version":"Next"},{"title":"Configuring difficulties​","type":1,"pageTitle":"Configuration","url":"/MTK-Dev/docs/Configuration#configuring-difficulties","content":" Many objects in the MTK (specifically Towers, Tower Rushes, and Endings), depend on Difficulty objects for describing it’s difficulty. These objects store information about single difficulty, it’s proper name, it’s color, etc.  All difficulty objects are stored in a ModuleScript named Difficulties, located in the ServerScriptService.GameData folder. From here you can modify existing difficulties, remove them, or add more. Here is a what an entry looks like:  Challenging = { Title = &quot;Challenging&quot;, Rating = 5, FancyFont = false, Color = Color3.fromRGB(194, 0, 0), GlobalAnnouncement = false },   For this example, the ID of the difficulty is Challenging, the ID should be unique for every difficulty, as it’s used for referring to this difficulty by other objects in the MTK. For example, if I had a difficulty with the ID Nefarious, and I wanted to configure a tower to use this difficulty, I would set it’s Difficulty property to Nefarious as well.The Title property should be the proper name of the difficulty that is displayed to the players.The Rating property is currently unused, but describes the difficulty’s placement if mapped on the spectrum of every other difficulty. For example, JToH places Easy at 1, Medium at 2, Hard at 3, etc.The FancyFont property describes whether or not an alternate font should be used for win messages. If false, the default font used for chat messages are used, Source Sans Bold 18pt. Otherwise, Bodoni 20pt will be used instead. In JToH this is typically used for Catastrophic and above.The Color property describes the color of the difficulty, at the moment it’s only used for win messages.The GlobalAnnouncement property dictates whether or not completions of towers using this difficulty should be broadcast globally, meaning across all servers in the game. In JToH, this is used for all soul-crushing difficulties.  ","version":"Next","tagName":"h2"},{"title":"Configuring endings​","type":1,"pageTitle":"Configuration","url":"/MTK-Dev/docs/Configuration#configuring-endings","content":" An ending is a special object that is unique to the towers themselves, and whenever a tower is beaten, an appropriate ending is selected depending on which winpad was touched, and uses it for displaying the win message.  The process of configuring endings is not immediately clear, whenever the place loads, the game will scan through every tower. For every tower it finds, a default ending is automatically created for that tower, inheriting the tower’s proper name and difficulty, as well as the tower’s acronym for the ending’s own ID. Furthermore, every tower has a unique list of endings, meaning 2 towers can have an ending with the same ID without there being problems, but this is not recommended as endings may be used in the future to track tower completions while differentiating alternate routes in towers.  Example Tower 1 (ET1)\tExample Tower 2 (ET2)ET1\tET2 ET2Secret  An example of how the default MTK place has it’s endings configured, each tower has an ending inheriting it’s ID from the tower acronym. Meanwhile, Example Tower 2 also has an alternate ending registered as ET2Secret.  To add an ending to a tower, start by giving it another winpad. In other words, add a part to the tower’s obby folder and name it WinPad. Next, add a StringValue to the winpad–and name it EndingID. Set the ending ID to any value, ideally formatted in PascalCase (though, it doesn’t matter), and just as long as it’s not the same as the tower’s acronym itself, as that ID is reserved for the tower’s default ending. You have now created an alternate ending for the tower! From here you can add extra properties to the ending.  note If a winpad has no extra information (specifically an EndingID), it is implied that it triggers the default ending. So if you don’t want to bother configuring a tower’s endings, you do not need to do anything more for the tower’s winpad to be functional.    Picture here is a winpad with extra properties added (especially EndingID), which will result in a new ending being created for this tower.  The EndingName StringValue describes the proper name of the ending. If this value is not supplied it will default to the proper name of the tower.The Difficulty StringValue references the ID of a difficulty. If this value is omitted, it will inherit the difficulty from the tower.The BadgeID IntValue is the badge ID to award the player when this specific ending is reached. This is completely seperate from the tower’s own badge, and will be awarded alongside the tower’s badge, unless the PreventTowerBadge BoolValue is present and set to true. Furthermore, just like any other BadgeID property, no badge will be awarded if the ID value is set to 0.The WinroomMarker StringValue will determine where the player is teleported when this ending is reached. Normally, when an ending is reached, you are teleported to the WinroomSpawn in the Markers folder. However, if this value is present, it will search for any part in the markers folder named the value of this property, and teleport you to that part instead.  After doing this, you will have successfully added another ending to your tower! Of course, you can repeat this process as many times as you like, just as long as every ending ID is unique.  note As of now, there is unfortunately no way to add multiple endings to a tower rush, as it has no list of endings. The tower rush’s own data is used for constructing a win message.  ","version":"Next","tagName":"h2"},{"title":"Adding a tower rush​","type":1,"pageTitle":"Configuration","url":"/MTK-Dev/docs/Configuration#adding-a-tower-rush","content":" To start, open up the RealmData folder in ServerScriptService, and open up the module in the folder named TowerRushes. This module contains the information for every tower rush in the realm. In order to add your own tower rush, duplicate the following code, and change the properties as explained below it:  ExampleTowerRush = { BadgeID = 0, Title = &quot;Example Tower Rush&quot;, Difficulty = &quot;Medium&quot;, WinroomMarker = &quot;&quot;, Towers = { &quot;ET1&quot;, &quot;ET2&quot;, } },   ExampleTowerRush is the ID of the tower rush, change it to something sensible, like Ring5TowerRush, or SecretTowerGauntlet, etc.The BadgeID property serves the same function it does for towers. It is the ID of the badge to be awarded upon completion of the tower rush, if set to 0, no badge is awarded.The Title property is the proper, displayed name of the tower rush.The Difficulty property serves the same function it does for towers. It references the name of a difficulty, and should be representative of the tower rush’s overall difficulty Again, for more information on configuring difficulties, see here. The WinroomMarker property lets you choose where the player is teleported upon completion of the tower rush. If set to a blank string, it will simply teleport the player to the default win room; In other words, the WinroomSpawn part in the Workspace.Markers folder. Otherwise, it should be the name of any part in the markers folder.Finally, there is the Towers property. It contains an array of towers (described via their acronyms) in order of appearance. Every item in this array should be the name of one of the towers inside of the Workspace.Towers folder surrounded by double-quotation marks.  note All tower rushes must have a unique ID for reference later, and must never conflict with another. Ideally they should be formatted in PascalCase, or be the acronym of the tower rush’s title, but it doesn’t truly matter.  danger In-case you are not familiar with Luau syntax, any item in a table must be separated by commas, if you do not do this, you will be met with an error. This applies to the entire tower rush info, and the tower acronyms in the Towers property.  ","version":"Next","tagName":"h2"},{"title":"Ever-present client objects​","type":1,"pageTitle":"Configuration","url":"/MTK-Dev/docs/Configuration#ever-present-client-objects","content":" The MTK has included &quot;ever-present client objects&quot; (ECOs), these are client objects that are always loaded in, even when a player enters or leaves a tower. They are useful for adding client objects to the lobby, or adding decorative client objects to a tower that are always loaded in.  Implementing ECOs is fairly straightforward. All ECOs are located in the EverpresentCOs folder found inside the towers folder. Treat it like you would any ClientSidedObjects folder, simply insert COs into this folder and they will become ECOs.    The EverpresentCOs as found inside the Towers folder.  Furthermore, the kit also provides every CO from the JToH Kit V5.4 already inside of the ECO folder for easy access.    ECOs included in the kit for easy access.  ","version":"Next","tagName":"h2"},{"title":"Creating a custom GUI​","type":1,"pageTitle":"Configuration","url":"/MTK-Dev/docs/Configuration#creating-a-custom-gui","content":" Creating a custom GUI for the MTK has always been a relatively easy task, assuming basic knowledge in creating UI in Roblox. You can format and organize anything in the TowerGUI ScreenGUI any way you want. As long as a UI element of a certain name exists, it will be controlled; You can even remove elements from the ScreenGUI, and it should still work.  ","version":"Next","tagName":"h2"},{"title":"Adding items​","type":1,"pageTitle":"Configuration","url":"/MTK-Dev/docs/Configuration#adding-items","content":" You are free to implement items in whatever way you want, whether that be as simple as placing tools in the StarterPack, or creating some intricate system for managing it like what JToH itself has. However, there are a few things to know when adding items.  If you want to add a boost item, you need to make sure it’s marked as such. Reason for doing so is because boost items tend to let players progress through the tower in unusual ways not normally intended, so it’s necessary for the builtin anti-cheat measures to be disabled when this happens to stop a player from being kicked for beating the tower in an unnatural way that the boost item made possible. Debug items (like the Noclip and Heal tools) should also be marked as such.  tip To mark an item as a boost item, add an attribute to it, name it BoostName, and make sure it’s type is string. To add a debug item that is only given to players in studio, place it in the StarterPackStudio folder, located in ServerStorage; It will automatically be marked as a debug item this way. ","version":"Next","tagName":"h2"},{"title":"Getting started","type":0,"sectionRef":"#","url":"/MTK-Dev/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Getting started","url":"/MTK-Dev/docs/intro#installation","content":" You can install the kit directly from the Releases page or the Template place. Download the .rbxl file, open it in Roblox Studio, and start building.  ","version":"Next","tagName":"h2"},{"title":"Setting up​","type":1,"pageTitle":"Getting started","url":"/MTK-Dev/docs/intro#setting-up","content":" From Official Sources: If you downloaded the kit from the Releases or the uncopylocked template place, everything is already set up.From Other Sources: If obtained from unofficial sources, additional setup may be required. Refer to the guide included with the download or contact the source of support.  ","version":"Next","tagName":"h2"},{"title":"Additional Features​","type":1,"pageTitle":"Getting started","url":"/MTK-Dev/docs/intro#additional-features","content":" Once the basics are set up, you can explore and customize other features of the kit as needed. These features are optional but can enhance your game. ","version":"Next","tagName":"h2"},{"title":"Types","type":0,"sectionRef":"#","url":"/MTK-Dev/api/Types","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#types","content":" ","version":null,"tagName":"h2"},{"title":"List<T>​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#List<T>","content":"&lt;/&gt; type List&lt;T&gt; = {[number]:T} Represents a simple ordered array of items, essentially an alias of {[number]:T} (or {T}).  ","version":null,"tagName":"h3"},{"title":"Dictionary<T>​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#Dictionary<T>","content":"&lt;/&gt; type Dictionary&lt;T&gt; = {[string]:T} Same as List&lt;T&gt;, but uses string indexes instead of number indexes.  ","version":null,"tagName":"h3"},{"title":"PlayerInfo​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#PlayerInfo","content":"&lt;/&gt; interface PlayerInfo { Player: Player -- A reference to the actual player instance in the Players service that this PlayerInfo is related to. GameTimer: number-- In seconds, how long the player has been in the game. This value is floored and sent to the leaderboard every second for the “Time” statistic. LastRestart: number-- How many seconds has passed since the player has last restarted a tower. This property is necessary for making sure they can’t lag out the server by imposing a cool-down. This cool-down duration can be changed in the game config via the RestartCooldown. CurrentTower: string-- The ID of the tower the player is currently playing. If the player is not in a tower, this value will be blank. CurrentTowerCheckpoint: number-- The index of the checkpoint the player is currently assigned to touch. Every time the appropriate checkpoint is touched, this value increments. If the referenced checkpoint does not exist, no checkpoint checks are done. If a player equips any debug items, this value is set to math.huge. BoostItemsUsed: boolean-- Tracks whether or not a boost item has been used in a tower or tower rush. Whenever a player loads in a tower, this value is reset to false, but the moment they equip a boost item, this value is set to true. TowerTimer: number-- In seconds, how long the player has been in a tower or tower rush. This value does not increment if the CurrentTower is blank; In other words, not currently in a tower. Although the client also keeps time for the same reason on it’s own, this value is sent to the client every 2 seconds to prevent the client’s timer from desynchronizing with the server’s timer. CurrentTowerRush: string-- The ID of the tower rush the player is currently playing. If the player is not in a tower rush, this value will be blank. This value should ideally only be set if CurrentTower is also set. CurrentTowerRushIndex: number-- The index of the current tower the player is at in the tower rush. TouchEventBusy: boolean-- This boolean is used internally by various callbacks as a debounce for touch events. IsLoadingTower: boolean-- This boolean is used as a debounce for tower loading. This property is set to true when a tower begins loading and reverts to false when it is finished. The loading of a tower cannot be initialized while this property is true. HasEverpresentCOs: boolean-- This boolean is used to determine if the player has already been sent ever-present client objects. If this value is true, the client’s requests for ever-present COs will be rejected to prevent malicious users from lagging out the server. }   ","version":null,"tagName":"h3"},{"title":"EndingInfo​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#EndingInfo","content":"&lt;/&gt; interface EndingInfo { Name: string-- The proper, human-readable name of this ending. Difficulty: string-- The name of the difficulty classification of this specific ending, it must be the name of a difficulty defined in GameData.Difficulties. Otherwise, a default difficulty will be used instead when obtaining the Difficulty info. BadgeID: number-- The ID of the badge to be awarded when this ending is triggered. If this value is set to 0, no badge will be awarded. Furthermore, this badge is separate from the tower’s badge, so if a tower’s badge, as well as this ending’s badge are both set, both badges will be awarded at the same time. PreventTowerBadge: boolean-- As mentioned above, both the tower badge and this ending’s own badge are awarded at the same time. However, if you want to suppress the tower badge from being awarded, enable this property. ParentTower: string-- The ID of the tower this ending belongs to. WinroomMarker: string-- The name of the marker the player should teleport to when this ending is triggered. If omitted, it the player will be teleported to the WinroomSpawn. }   ","version":null,"tagName":"h3"},{"title":"TowerInfo​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#TowerInfo","content":"&lt;/&gt; interface TowerInfo { Name: string-- The full, human-readable name of the tower. For example, if you have a tower folder named “ToH”, an appropriate value for this property would be “Tower of Hecc”. Difficulty: string-- The name of the difficulty classification of this tower, it must be the name of a difficulty defined in GameData.Difficulties. Otherwise, a “default” difficulty will be used instead when obtaining the Difficulty info. BadgeID: number-- The ID of the badge to award the player upon beating this tower. If the value is 0, no badge will be awarded. Folder: Instance -- A reference to the folder representing the tower in the workspace. The name of this folder will be used as the internal ID for this tower. SpawnLocation: BasePart -- A reference to the part representing the position where the player should spawn upon entering the tower. Do not use an actual SpawnLocation, as it isn’t necessary and is prone to breaking the game, just use a regular part. ClientObjects: Instance? -- A reference to the folder containing the tower’s client objects. If the tower does not contain a ClientSidedObjects folder, this property will be set to nil, and the tower will be marked as “Purist”. Endings: Dictionary&lt;EndingInfo&gt;-- A dictionary of endings for this tower. The string keys represent the names of the endings, while the values contain information about the endings. MinimumTime: number-- The minimum amount of time (measured in seconds) that the player must spend in a tower before they can touch the winpad, otherwise, they will be kicked from the game. Setting this value to 0 effectively disables this measure. Checkpoints: List&lt;BasePart &gt;-- An ordered list of checkpoints, that must be touched by the player’s pivot point in order to complete the tower. Failing to touch each checkpoint will result in the player being kicked. CheckpointCount: number-- Describes how many checkpoints the tower has. This property is figured out automatically and is used internally. }   ","version":null,"tagName":"h3"},{"title":"TowerRush​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#TowerRush","content":"&lt;/&gt; interface TowerRush { BadgeID: number-- The ID of the badge to award the player upon beating this tower. If the value is 0, no badge will be awarded. Title: string-- The full, human-readable name of the tower. For example, if you have a tower folder named “ToH”, an appropriate value for this property would be “Tower of Hecc”. Difficulty: string-- The name of the difficulty classification of this specific ending, it must be the name of a difficulty defined in GameData.Difficulties. Otherwise, a default difficulty will be used instead when obtaining the Difficulty info. WinroomMarker: string-- The name of the marker the player should teleport to when this ending is triggered. If omitted, it the player will be teleported to the WinroomSpawn. Towers: List&lt;string&gt;-- A list of every tower that the player must progress through in the tower rush, in order of progression. }   ","version":null,"tagName":"h3"},{"title":"DifficultyInfo​","type":1,"pageTitle":"Types","url":"/MTK-Dev/api/Types#DifficultyInfo","content":"&lt;/&gt; interface DifficultyInfo { Rating: number-- The difficulty’s baseline represented as a number. In JToH, Easy is 1, and Catastrophic is 11. Title: string-- The proper name of this difficulty. If the ID name of this difficulty is “ATrulyHardDifficulty”, a good title would be “A Truly Hard Difficulty”. FancyFont: boolean-- Determines if 20pt Bodoni should be used as the font when displaying a win message, instead of the standard 18pt Source Sans Bold. In JToH, Bodoni font win messages are used for Catastrophic difficulty and above. Color: Color3 -- The color of this difficulty, normally used for win messages. GlobalAnnouncement: boolean-- If set to true, victors of any tower/tower rush of this difficulty will have their win messages broadcast throughout the entire game, on other servers. }  ","version":null,"tagName":"h3"},{"title":"Using the Kit","type":0,"sectionRef":"#","url":"/MTK-Dev/docs/UsingTheKit","content":"","keywords":"","version":"Next"},{"title":"Adding a tower​","type":1,"pageTitle":"Using the Kit","url":"/MTK-Dev/docs/UsingTheKit#adding-a-tower","content":" Adding a tower is at the core of this kit, It's pretty much the whole reason one would use this kit. To add a tower, start by inserting a tower, or even a blank kit, into the workspace. After it is inserted, move it into the Towers folder.  Rename the tower to the acronym of the tower; Be reasonable, as it's acronym will be used as the tower's internal identifier, and will be shown next to the timer on the client's GUI.  The tower should be organized the same way any tower is normally organized. The kit folder should contain:  The Obby folder which contains all of the normal, static parts. Most of which make up the gameplay of the tower.The Frame folder/model, which contains the parts that make up the frame of the tower. This functionally is exactly the same as the obby folder, but a distinction will be important in the future, as I plan on adding a low-detail mode1 to the kit in the future.The ClientSidedObjects folder contains all of the client objects for the tower. When the game loads, every tower’s ClientSidedObjects folder is moved into storage (game.ServerStorage.TowerClientObjects), and is served to a client whenever they load a tower. Optionally, you may move this folder to the TowerClientObjects folder yourself in studio, just as long as the folder is renamed to be the same as the tower’s acronym.The folder itself is optional too, the kit will function if this folder is removed completely, making it a true “purist”2 tower.    info In this image, an example tower is shown appropriately inserted into the Towers folder. Because this tower is called &quot;Example Tower 1&quot;, the folder is named after it's acronym, &quot;ET1&quot;.  After inserting the tower into the place, you must give it some properties to make it work with the MTK. Properties may be inserted in 2 ways: The first being adding an attribute to the tower folder, the second being adding a ValueBase (BoolValue, StringValue, NumberValue, etc) instance to the folder. For convenience sake, ValueBases are used by default in the kit. Here are the following properties that must be added to the tower folder:  A BadgeID IntValue. When the tower is beaten by the player, they will be awarded a badge, the value of this property being the ID of the badge awarded. If the value is 0, no badge will be awarded.A Difficulty StringValue. This will point to a difficulty defined in the Difficulties3 module. If it does not name an existing difficulty, a default difficulty will be used, which is heavily discouraged. Difficulties are explain further in here. For now, any built-in difficulty works, those being: Impossible, Easy, Medium, Hard, Difficult, Challenging, Intense, Remorseless, Insane, Extreme, Terrifying, Catastrophic, Horrific, and Unreal. A MinimumTime NumberValue. This property describes how much time (in seconds) a player must be in a tower for a completion to be considered legitimate. If the tower is beaten before the timer passes this value, the player will be kicked for cheating.A ProperName StringValue. This property describes the proper name of the tower, as the name of the folder is merely the acronym. The proper name is usually used for win messages. For example: If i had a tower folder named ToS, a reasonable value for this property would be Tower of Stress.    This image depicts the folder structure of Example Tower 1 as shown earlier, but with the new properties added.  At this point, the tower has been fully implemented. It just needs a portal to be entered.  ","version":"Next","tagName":"h2"},{"title":"Creating portals​","type":1,"pageTitle":"Using the Kit","url":"/MTK-Dev/docs/UsingTheKit#creating-portals","content":" Portals are the parts that load a tower when a player touches it, as well as teleporting them to the tower’s SpawnLocation. All portal parts must be put in the Portals folder in the workspace to work.  To create a portal, start by inserting a BasePart into the Portals folder. Then, add a StringValue to the portal part named TowerPortal. Alternatively, you can duplicate any of the portals included with the template place. Set the value of the TowerPortal string to the acronym of any tower, more accurately, the name of any folder in the Towers folder.    A bare minimum setup of the Portals folder, including 3 portals.  note The parts in the folder does not actually matter.  You can also choose to instead give a TowerPortal a StringValue named LobbyTeleporter. This will turn it into a server-sided teleporter. Set it’s value to the name of any part in the Markers folder, and touching it in-game will teleport the player to that marker.  ","version":"Next","tagName":"h2"},{"title":"Adding anti-cheat checkpoints to a tower​","type":1,"pageTitle":"Using the Kit","url":"/MTK-Dev/docs/UsingTheKit#adding-anti-cheat-checkpoints-to-a-tower","content":" Anti-cheat checkpoints are a new feature to the MTK that acts similarly to the checkpoints in JToH. They are invisible blocks never seen by the client, and the character must pass through them in order. Failure to do so will result in the player being kicked for completing the tower out of order.  info Every tower’s checkpoints can be defined as a list of parts.  This list is constructed from a folder, either Checkpoints inside the tower folder itself, or a folder named the same as the tower acronym inside the TowerCheckpoints folder inside ServerStorage.  warning If the checkpoints folder is kept in the tower folder, you will be warned for doing so, as leaving anything in the workspace is at risk of being obtained by exploiters, with checkpoints being too important to be made easily visible. Therefore, keeping them stored inside of ServerStorage is much safer, as it’s secure, and never has a chance of replicating to the client.  danger Every instance inside of the checkpoints folder must be named in order, with the very first checkpoint being named 1, the second being named 2, the third being named 3, etc. Failure to do so will result in an error. Every instance must be also BasePart.    The checkpoints folder as found in ServerStorage. ET2's checkpoints folder is expanded to show the parts inside it.  At the moment, checkpoint touch detection works by seeing if the character’s pivot point is inside the oriented bounding-box area of the part. This means that you can position and rotate the part as much as you want, but it will be treated like a box, regardless of it’s actual shape.  tip Make sure the checkpoint parts are reasonably large, as the kit will only check if a player is inside a checkpoint every 0.25 seconds. This rate can be changed in the GameData.Config module, specifically the CheckpointInterval property.  ","version":"Next","tagName":"h2"},{"title":"Building the lobby and setting up markers​","type":1,"pageTitle":"Using the Kit","url":"/MTK-Dev/docs/UsingTheKit#building-the-lobby-and-setting-up-markers","content":" Probably one of the most crucial part of your player’s experience is not just the towers, but the place the towers sit in itself. There’s not much important information to list in regards to building the lobby in this manual as that’s mostly going to be your responsibility. However there are some important things to consider:  Keep things properly organized. There’s a folder in the workspace called Lobby, and anything related to the lobby should ideally be kept in this folder.Avoid use of physics constraints on the server-side. Any constraints, or special objects of any kind for that matter, should be made into client objects. Lobby COs are discussed further in here.  Aside from this, there’s the markers folder which is useful for placing markers of different kinds around the map. This includes spawn points, teleporter portal destinations, etc. To create a marker, simply create a part in the Markers folder, and name whatever you wish. Naming markers certain things will give it special functionality, a list of markers and their functions are listed below:  SpawnLocation is a SpawnLocation part that acts as the default spawn, and should ideally be where all players in the Start team spawn.WinroomSpawn is also a SpawnLocation, but is specifically attributed to the Winners team. It’s also where all win pads will teleport the player by default unless specified otherwise.LobbyTP is a server-sided teleporter part. When a player touches it, they will be teleported to the Start team’s SpawnLocation, and will be re-assigned to the Start team if they aren’t a member already. This should ideally be used in sky lobbies and winrooms.  Any marker without a name listed above doesn’t get any special functionality. They will just be plain parts that don’t do anything on their own. The reason you would need to create parts like these is usually to act as destinations for teleporters. Lobby portals will search the Markers folder for a part named the value of it’s LobbyTeleporter value. Win pads on the other hand can be optionally configured to teleport to a marker of a specific name instead of the WinroomSpawn.    Footnotes​ Low-Detail Mode (LDM) is a feature in Juke’s Towers of Hell where the Obby folder’s contents of every tower are hidden, unless that tower is being played. However, the frame folder will be left untouched. The point of this feature is to put less stress on lower-end devices by having less things onscreen for the device to render. ↩ Although sometimes the definition is stretched to allow for purely cosmetic client objects, the MTK defines &quot;purist&quot; towers as having no client objects at all. ↩ This module is located in game.ServerScriptService.GameData.Difficulties. ↩ ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}